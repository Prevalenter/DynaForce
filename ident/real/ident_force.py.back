
import numpy as np
import matplotlib.pyplot as plt

import sys
sys.path.append('../..')

from utils.identification.core import IdentFingaer, process_data
from utils.identification.metric import mse, relative_error

# from ident.sim.env import GX11PMEnv
from rviz.rviz_pub import rviz_pub

import scipy.signal as signal
import time

from libgex.libgex.libgx11 import Hand

import rospy

# import pybullet as p
# import pybullet_data
from ident.sim.env import GX11PMEnv



# class HandForce:
#     def __init__(self):
#         pass
    
#     def load_default_params(self):


    
    
if __name__ == '__main__':
    
    torque_norm =1000
    urdf_sign = np.array([1, 1, 1,
                        1, -1, -1, -1,
                        -1, -1, 1, 1])[None]
    
    # fix the seed of numpy and random
    np.random.seed(42)
    
    default_joint = [np.pi/4, 0, 0,
                    0, 0, 0, 0,
                    0, 0, 0, 0,
                    ]
    
    result_map = [
		[0, 1, 2],
		[3, 4, 5, 6],
		[7, 8, 9, 10]
	]

    finger_list = []
    
    env_pybullet = GX11PMEnv(headless=True)
    
    rviz = rviz_pub()

    time.sleep(1)

    
    for joint_idx in [0, 1, 2]:
        print(f'joint_idx: {joint_idx}')

        exp_idx = 2
        
        joint_mask = np.zeros(11)
        if joint_idx == 0:
            joint_mask[:3] = 1
        elif joint_idx == 1:
            joint_mask[3:7] = 1
        elif joint_idx == 2:
            joint_mask[7:11] = 1
        # joint_mask[:3] = 1
        joint_mask = joint_mask.astype(bool)
        
        finger = IdentFingaer(f'../../data/model/gx11pm_finger{joint_idx+1}.pkl', joint_mask=joint_mask)
        
        q_raw = np.load(f'../../data/ident/pos_list_{joint_idx}_{exp_idx}.npy')
        torque_raw = np.load(f'../../data/ident/torque_list_{joint_idx}_{exp_idx}.npy')
        t_list_raw = np.load(f'../../data/ident/t_list_{joint_idx}_{exp_idx}.npy')

        algo = 'ols'

        # get beta
        q, qd, qdd, torque = process_data(q_raw.copy(), torque_raw.copy(), t_list_raw.copy(), urdf_sign=urdf_sign)
        finger.ident_params(q, qd, qdd, torque, algo=algo)
        # print(q.max(), q.min())
        
        # breakpoint()
        finger_list.append(finger)

    hand = Hand(port='/dev/ttyACM0', kin=False) # COM* for Windows, ttyACM* or ttyUSB* for Linux
    hand.connect(goal_pwm=600) # goal_pwm changes the speed, max 855
    

    hand.home() # home the hand
    time.sleep(1)
    hand.setj(np.array(default_joint)*(180/np.pi)) # set the joint position
    time.sleep(1)


    last_acc = np.zeros(11)
    last_vel = np.zeros(11)
    last_pos = np.zeros(11)
    
    
    is_detection_link = False

    finger_fix_threshold_scale = [np.array([0.03 , 0.06, 0.024]), 
                                  np.array([0.1, 0.05, 0.04, 0.035]), 
                                  np.array([0.1, 0.05, 0.05, 0.024])]
    
    last_time = time.time()
    
    force_fingers = [
        np.zeros((3, 1)),
        np.zeros((3, 1)),
        np.zeros((3, 1)),
    ]
    
    # ema_factor = [0.8, 0.8, 0.8]
    ema_factor = [0.0, 0.0, 0.0]
    print('begin identification')

    for t in range(int(1e4)):
        # sim.step()
        time_begin = time.time()
        # print('-'*50, t)
        # time.sleep(0.1)
        rospy.sleep(0.1)

        # updatae the data
        pos = np.array(hand.getj())

        cur = np.array(hand.get_current())
        cur[cur>32767] = cur[cur>32767]- 65536
        
        cur = cur*urdf_sign[0]/torque_norm
        
        # print(f'pos: {cur[7:]}')

        cur_pos = pos.copy()*(np.pi/180)*urdf_sign[0]
        cur_vel = (cur_pos - last_pos) / (time.time() - last_time)
        cur_acc = (cur_vel - last_vel) / (time.time() - last_time)
        
        # breakpoint()
        
        
        if t>=10:
            
            for finger_idx, finger in enumerate(finger_list):
                cur_fingertip_force = np.zeros((3, 1))
                
                # breakpoint
                torque = cur[finger.joint_mask]

                # pred torque
                pred_torque_i = finger.pred_torque(cur_pos[None], cur_vel[None], cur_acc[None])
                pred_torque_i = np.array(pred_torque_i)
                error = torque[None] - pred_torque_i


                collision_links = []
                collision_joint_idx = np.abs(error)>finger_fix_threshold_scale[finger_idx][None]
                if (collision_joint_idx).sum()>0:

                    joint_idx_forced = np.where(collision_joint_idx)[1]
                    collision_contact_link = np.max(joint_idx_forced)
                    
                    # only in the fingertip
                    cur_collision_link = result_map[finger_idx][collision_contact_link]
                    # if cur_collision_link in [2, 6, 10]:
                    if True:
                        collision_links.append(cur_collision_link)

                        if finger_idx == 0:
                            link_name = "hand_/Link12"
                            jac_link_idx = 3
                        elif finger_idx == 1:
                            link_name = "hand_/Link13"
                            jac_link_idx = 8
                        elif finger_idx == 2:
                            link_name = "hand_/Link14"
                            jac_link_idx = 13
                    
                        # get the jacobian
                        # cur_pos_rad = cur_pos # *(np.pi/180)
                        jacobian_np = env_pybullet.get_jaccobian(joint_pos=default_joint, link_idx=jac_link_idx)

                        jacobian_np[np.abs(jacobian_np)<0.01] = 0

                        cur_finger_mask = np.abs(error)>finger_fix_threshold_scale[finger_idx][None]
                        error[cur_finger_mask==False] = 0
                        res_tau = error
                        # res_tau[:, :-1] = 0
                        print(res_tau.round(3))
                        print(np.linalg.pinv(jacobian_np.round(2).T)[:, finger.joint_mask].round(3))


                        force_pred = np.linalg.pinv(jacobian_np.round(2).T)[:, finger.joint_mask]@res_tau.T

                        cur_fingertip_force = force_pred

                        trans = rviz.get_relative_position('hand_/base_link', link_name)
                        
                        # breakpoint()


                force_fingers[finger_idx] = force_fingers[finger_idx]*ema_factor[finger_idx] + cur_fingertip_force*(1-ema_factor[finger_idx])

                # if with fingertip force, visualize
                if np.linalg.norm(force_fingers[finger_idx])>0.04:

                    rviz.pub_hand_base_link()
                    base_link_name = 'hand_/base_link'
                    rviz.vis_force(link_name=base_link_name, force=force_pred, scale=0.5, lifetime=0.4, start_bias=trans[0])
                        
                pos_pub = cur_pos
                
                rviz.pub_joint_state(pos_pub)

                rviz.vis_collision_links(collision_links)
            
        # update the last data
        cur_torque = cur

        last_pos = cur_pos.copy()
        last_vel = cur_vel
        last_acc = cur_acc
        last_time = time.time()


        # print(time.time() - time_begin)
        
